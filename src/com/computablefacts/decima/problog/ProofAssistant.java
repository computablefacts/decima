package com.computablefacts.decima.problog;

import java.util.*;
import java.util.stream.Collectors;

import com.google.common.base.Preconditions;
import com.google.common.collect.Lists;
import com.google.common.collect.Sets;
import com.google.errorprone.annotations.CheckReturnValue;

/**
 * See Mantadelis, Theofrastos & Janssens, Gerda. (2010). "Dedicated Tabling for a Probabilistic
 * Setting". Technical Communications of ICLP. 7. 124-133. 10.4230/LIPIcs.ICLP.2010.124. for
 * details.
 */
@CheckReturnValue
final public class ProofAssistant {

  // The intermediate proofs generated by the tabling algorithm
  private final Set<Literal> facts_;
  private final Set<Clause> rulesWithSubRules_;
  private final Set<Clause> rulesWithoutSubRules_;

  public ProofAssistant(Collection<Subgoal> subgoals) {

    Preconditions.checkNotNull(subgoals, "subgoals should not be null");

    facts_ = subgoals.stream().filter(subgoal -> subgoal.rules().isEmpty())
        .flatMap(subgoal -> Sets.newHashSet(subgoal.facts()).stream()).map(Clause::head)
        .collect(Collectors.toSet());

    rulesWithoutSubRules_ =
        subgoals.stream().flatMap(subgoal -> subgoal.proofs().stream()).filter(Clause::isGrounded)
            .filter(rule -> rule.body().stream()
                .allMatch(literal -> literal.predicate().isPrimitive() || facts_.contains(literal)))
            .collect(Collectors.toSet());

    rulesWithSubRules_ =
        subgoals.stream().flatMap(subgoal -> subgoal.proofs().stream()).filter(Clause::isGrounded)
            .filter(rule -> rule.body().stream().anyMatch(
                literal -> !literal.predicate().isPrimitive() && !facts_.contains(literal)))
            .collect(Collectors.toSet());
  }

  public Set<Clause> proofs(Literal curLiteral) {
    return proofs(curLiteral, new HashSet<>(), 0);
  }

  private Set<Clause> proofs(Literal curLiteral, Set<Clause> visited, int depth) {

    Preconditions.checkNotNull(curLiteral, "curLiteral should not be null");
    Preconditions.checkNotNull(visited, "visited should not be null");
    Preconditions.checkArgument(depth >= 0, "depth should be >= 0");

    if (facts_.stream().anyMatch(fact -> fact.isRelevant(curLiteral))) {
      return facts_.stream().filter(literal -> literal.isRelevant(curLiteral)).map(Clause::new)
          .collect(Collectors.toSet());
    }

    Set<Clause> rulesWithSubRules = rulesWithSubRules_.stream()
        .filter(clause -> clause.head().isRelevant(curLiteral)).collect(Collectors.toSet());

    Set<Clause> rulesWithoutSubRules = rulesWithoutSubRules_.stream()
        .filter(clause -> clause.head().isRelevant(curLiteral)).collect(Collectors.toSet());

    Set<Clause> proofs = new HashSet<>();
    Set<Clause> rules =
        Sets.difference(Sets.union(rulesWithoutSubRules, rulesWithSubRules), visited);

    for (Clause rule : rules) {

      Set<Clause> newVisited = new HashSet<>(visited);

      if (rulesWithSubRules.stream().anyMatch(clause -> clause.isRelevant(rule))) {
        newVisited.add(rule);
      }

      Set<List<Literal>> newBodies = new HashSet<>();

      for (Literal literal : rule.body()) {

        Set<List<Literal>> newNewBodies = new HashSet<>();

        if (literal.predicate().isPrimitive()/* function */ || facts_.stream()
            .anyMatch(fact -> fact.isRelevant(literal)) /* fact */) {
          if (newBodies.isEmpty()) {
            newNewBodies.add(Lists.newArrayList(literal));
          } else {
            for (List<Literal> body : newBodies) {
              List<Literal> nb = new ArrayList<>(body);
              nb.add(literal);
              newNewBodies.add(nb);
            }
          }
        } else {

          Set<Clause> proofz = proofs(literal, newVisited, depth + 1);

          if (proofz.isEmpty()) {
            break; // a cycle has been detected in the current proof
          }

          for (Clause proof : proofz) {
            if (newBodies.isEmpty()) {
              if (proof.isFact()) {
                newNewBodies.add(Lists.newArrayList(proof.head()));
              } else {
                newNewBodies.add(new ArrayList<>(proof.body()));
              }
            } else {
              for (List<Literal> body : newBodies) {
                List<Literal> nb = new ArrayList<>(body);
                if (proof.isFact()) {
                  nb.add(proof.head());
                } else {
                  nb.addAll(proof.body());
                }
                newNewBodies.add(nb);
              }
            }
          }
        }

        newBodies.clear();
        newBodies.addAll(newNewBodies);
      }

      for (List<Literal> body : newBodies) {
        proofs.add(new Clause(rule.head(), body));
      }
    }
    return proofs;
  }
}
